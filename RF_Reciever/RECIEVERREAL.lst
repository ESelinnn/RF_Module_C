CCS PCH C Compiler, Version 5.100, 61971               18-Nis-21 01:12

               Filename:   C:\Users\emine\Desktop\ActiMooRFM\TRANSRECIEVER\RECIEVERREAL\RECIEVERREAL.lst

               ROM used:   1224 bytes (2%)
                           Largest free fragment is 64312
               RAM used:   18 (0%) at main() level
                           35 (1%) worst case
               Stack used: 2 locations
               Stack size: 31

*
00000:  GOTO   03B4
.................... #include <RECIEVERREAL.h>
.................... #include <18LF46K22.h>
.................... //////////// Standard Header file for the PIC18LF46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18LF46K22
00004:  DATA 64,61
00006:  DATA 74,61
00008:  DATA 20,69
0000A:  DATA 73,3D
0000C:  DATA 20,25
0000E:  DATA 63,20
00010:  DATA 0A,20
00012:  DATA 00,00
*
00396:  TBLRD*+
00398:  MOVFF  FF6,12
0039C:  MOVFF  FF7,13
003A0:  MOVFF  FF5,14
003A4:  RCALL  0348
003A6:  MOVFF  12,FF6
003AA:  MOVFF  13,FF7
003AE:  DECFSZ 11,F
003B0:  BRA    0396
003B2:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=16
.................... #FUSES NOMCLR
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode)
.................... unsigned char spi_R(unsigned char data);
.................... void SI4432_RX_init_parameter(void);
.................... void rx_data();
.................... unsigned char spi_writex(unsigned char addr, unsigned char data);
.................... unsigned char spi_readx(unsigned char addr );
.................... #define SI4432_PWRSTATE_READY 01 // Si4432 ready mode define
.................... #define SI4432_PWRSTATE_TX 0x09 // Si4432 Tx mode define
.................... #define SI4432_PWRSTATE_RX 05 // Si4432 Rx mode define
.................... #define SI4432_PACKET_SENT_INTERRUPT 04 // Si4432 packet sent interrupt define
.................... #define SI4432_Rx_packet_received_interrupt 0x02 // Si4432 packet received interrupt define
.................... 
.................... #define TX1_RX0 spi_writex(0x0e|0x80, 0x01) // Antenna switch to tx mode
.................... #define TX0_RX1 spi_writex(0x0e|0x80, 0x02) // Antenna switch to Rx mode
.................... #define TX0_RX0 spi_writex(0x0e|0x80, 0x00) // Antenna is not in Tx/Rx mode
.................... 
.................... #define LEDB5 PIN_B5 //(output)
.................... #define SDO PIN_D3 //  (OUTPUT) PIC E GÖRE
.................... #define SDI PIN_C4 //  (INPUT)
.................... #define SCLK PIN_D2 // (OUTPUT)
.................... #define nSEL PIN_D1 // (OUTPUT)
.................... #define nIRQ PIN_D0 // (INPUT)
.................... #use delay(clock=64MHz,crystal=16MHz)
*
00290:  CLRF   FEA
00292:  MOVLW  10
00294:  MOVWF  FE9
00296:  MOVF   FEF,W
00298:  BZ    02B6
0029A:  MOVLW  14
0029C:  MOVWF  01
0029E:  CLRF   00
002A0:  DECFSZ 00,F
002A2:  BRA    02A0
002A4:  DECFSZ 01,F
002A6:  BRA    029E
002A8:  MOVLW  BF
002AA:  MOVWF  00
002AC:  DECFSZ 00,F
002AE:  BRA    02AC
002B0:  BRA    02B2
002B2:  DECFSZ FEF,F
002B4:  BRA    029A
002B6:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_A1,rcv=PIN_A2,bits=8,stream=PORT1)
*
00348:  BCF    F92.1
0034A:  BCF    F89.1
0034C:  MOVLW  08
0034E:  MOVWF  01
00350:  BRA    0352
00352:  NOP   
00354:  BSF    01.7
00356:  BRA    0374
00358:  BCF    01.7
0035A:  RRCF   14,F
0035C:  BTFSC  FD8.0
0035E:  BSF    F89.1
00360:  BTFSS  FD8.0
00362:  BCF    F89.1
00364:  BSF    01.6
00366:  BRA    0374
00368:  BCF    01.6
0036A:  DECFSZ 01,F
0036C:  BRA    035A
0036E:  BRA    0370
00370:  NOP   
00372:  BSF    F89.1
00374:  MOVLW  02
00376:  MOVWF  00
00378:  CLRF   FE9
0037A:  DECFSZ FE9,F
0037C:  BRA    037A
0037E:  DECFSZ 00,F
00380:  BRA    0378
00382:  MOVLW  23
00384:  MOVWF  FE9
00386:  DECFSZ FE9,F
00388:  BRA    0386
0038A:  NOP   
0038C:  BTFSC  01.7
0038E:  BRA    0358
00390:  BTFSC  01.6
00392:  BRA    0368
00394:  RETURN 0
.................... 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... unsigned char ItStatus1,ItStatus2;
.................... unsigned char rx_buf[9];
.................... 
.................... 
.................... 
.................... void main()
*
003B4:  CLRF   FF8
003B6:  BCF    FD0.7
003B8:  BCF    F92.1
003BA:  BSF    F89.1
003BC:  MOVLB  F
003BE:  CLRF   x38
003C0:  CLRF   x39
003C2:  CLRF   x3A
003C4:  CLRF   x3B
003C6:  CLRF   x3C
003C8:  CLRF   F77
003CA:  CLRF   F78
003CC:  CLRF   F79
.................... {
....................    unsigned char i;
....................    set_tris_d(0b00000001);
003CE:  MOVLW  01
003D0:  MOVWF  F95
....................    set_tris_b(0b00000000);
003D2:  MOVLW  00
003D4:  MOVWF  F93
....................    set_tris_c(0b00010000);
003D6:  MOVLW  10
003D8:  MOVWF  F94
....................    SI4432_RX_init_parameter();
003DA:  MOVLB  0
003DC:  BRA    00DE
....................    spi_writex(0x0e|0x80, 0x00); // TX0_RX0 Antenna is not in Tx/Rx mode 
003DE:  MOVLW  8E
003E0:  MOVWF  13
003E2:  CLRF   14
003E4:  RCALL  0076
....................    while(TRUE)
....................    {    
....................       delay_ms(100);
003E6:  MOVLW  64
003E8:  MOVWF  10
003EA:  RCALL  0290
....................       rx_data();
003EC:  BRA    02B8
....................       while(input(nIRQ));
003EE:  BSF    F95.0
003F0:  BTFSC  F83.0
003F2:  BRA    03EE
....................       if(!input(nIRQ))
003F4:  BSF    F95.0
003F6:  BTFSC  F83.0
003F8:  BRA    04C4
....................       { 
....................          for(i=0;i<5;i++)
003FA:  CLRF   0F
003FC:  MOVF   0F,W
003FE:  SUBLW  04
00400:  BNC   041A
....................          {
....................             output_high(LEDB5);
00402:  BCF    F93.5
00404:  BSF    F8A.5
....................             delay_ms(200);
00406:  MOVLW  C8
00408:  MOVWF  10
0040A:  RCALL  0290
....................             output_low(LEDB5);
0040C:  BCF    F93.5
0040E:  BCF    F8A.5
....................             delay_ms(200);
00410:  MOVLW  C8
00412:  MOVWF  10
00414:  RCALL  0290
00416:  INCF   0F,F
00418:  BRA    03FC
....................          }
.................... 
....................       ItStatus1 = spi_readx(0x03); // read status, clear interrupt
0041A:  MOVLW  03
0041C:  MOVWF  13
0041E:  RCALL  0014
00420:  MOVFF  01,04
....................       ItStatus2 = spi_readx(0x04);
00424:  MOVLW  04
00426:  MOVWF  13
00428:  RCALL  0014
0042A:  MOVFF  01,05
....................       output_low(SCLK);
0042E:  BCF    F95.2
00430:  BCF    F8C.2
....................       output_low(nSEL); // must be low during the addr write
00432:  BCF    F95.1
00434:  BCF    F8C.1
....................       spi_R(0x7f);
00436:  MOVLW  7F
00438:  MOVWF  12
0043A:  RCALL  0310
....................       for( i=0;i<9;i++)
0043C:  CLRF   0F
0043E:  MOVF   0F,W
00440:  SUBLW  08
00442:  BNC   046C
....................          {
....................             rx_buf[i]=spi_R(0x00);
00444:  CLRF   03
00446:  MOVF   0F,W
00448:  ADDLW  06
0044A:  MOVWF  01
0044C:  MOVLW  00
0044E:  ADDWFC 03,F
00450:  MOVFF  01,10
00454:  MOVFF  03,11
00458:  CLRF   12
0045A:  RCALL  0310
0045C:  MOVFF  11,FEA
00460:  MOVFF  10,FE9
00464:  MOVFF  01,FEF
00468:  INCF   0F,F
0046A:  BRA    043E
....................          }
....................       output_high(nSEL); 
0046C:  BCF    F95.1
0046E:  BSF    F8C.1
....................       spi_writex(0x07, SI4432_PWRSTATE_READY); // Exit Rx mode after all the data read from the FiFo
00470:  MOVLW  07
00472:  MOVWF  13
00474:  MOVLW  01
00476:  MOVWF  14
00478:  RCALL  0076
....................            
....................         // chksum = 0;
....................         // for(i=0;i<3;i++) // calculate the checksum for the received data
....................          //{chksum += rx_buf[i];}
....................          //if(( chksum== rx_buf[3] )&&( rx_buf[0] == 0x41 ))
.................... //!       if(rx_buf[0] == 0x41 )
.................... //!         {
....................           
....................                output_high(LEDB5);
0047A:  BCF    F93.5
0047C:  BSF    F8A.5
....................                delay_ms(30);
0047E:  MOVLW  1E
00480:  MOVWF  10
00482:  RCALL  0290
....................                for(i=0;i<9;i++)
00484:  CLRF   0F
00486:  MOVF   0F,W
00488:  SUBLW  08
0048A:  BNC   04C4
....................                {
....................                printf("data is= %c \n ",rx_buf[i]);// data verified OK
0048C:  CLRF   03
0048E:  MOVF   0F,W
00490:  ADDLW  06
00492:  MOVWF  FE9
00494:  MOVLW  00
00496:  ADDWFC 03,W
00498:  MOVWF  FEA
0049A:  MOVFF  FEF,10
0049E:  MOVLW  04
004A0:  MOVWF  FF6
004A2:  MOVLW  00
004A4:  MOVWF  FF7
004A6:  MOVLW  09
004A8:  MOVWF  11
004AA:  RCALL  0396
004AC:  MOVFF  10,14
004B0:  RCALL  0348
004B2:  MOVLW  0F
004B4:  MOVWF  FF6
004B6:  MOVLW  00
004B8:  MOVWF  FF7
004BA:  MOVLW  03
004BC:  MOVWF  11
004BE:  RCALL  0396
004C0:  INCF   0F,F
004C2:  BRA    0486
....................                }
.................... 
....................          //   }
....................         
.................... //!         else
.................... //!         {
.................... //!           printf("Data Verified error, then restart to Rx");
.................... //!             for(i=0;i<7;i++)
.................... //!        {
.................... //!           output_high(LEDB5);
.................... //!           delay_ms(50);
.................... //!           output_low(LEDB5);
.................... //!            delay_ms(50);
.................... //!         }
.................... //!            rx_data(); // Data Verified error, then restart to Rx
.................... //!          }
....................       
....................       }
004C4:  BRA    03E6
....................    }
.................... 
.................... }
....................  
004C6:  SLEEP 
....................  void SI4432_RX_init_parameter(void)
*
000DE:  MOVLW  53
000E0:  MOVWF  10
000E2:  MOVLW  64
000E4:  MOVWF  11
000E6:  CLRF   12
.................... {
....................    unsigned char fb=0x53,fc0=0x64,fc1=0x00; // //434 mhz
....................    ItStatus1 = spi_readx(0x03); // read status, clear interrupt
000E8:  MOVLW  03
000EA:  MOVWF  13
000EC:  RCALL  0014
000EE:  MOVFF  01,04
....................    ItStatus2 = spi_readx(0x04);
000F2:  MOVLW  04
000F4:  MOVWF  13
000F6:  RCALL  0014
000F8:  MOVFF  01,05
....................    spi_writex(0x06, 0x00); // no wakeup up, lbd,
000FC:  MOVLW  06
000FE:  MOVWF  13
00100:  CLRF   14
00102:  RCALL  0076
....................    spi_writex(0x07, SI4432_PWRSTATE_READY); // disable lbd, wakeup timer, use internal 32768,xton = 1; in ready mode
00104:  MOVLW  07
00106:  MOVWF  13
00108:  MOVLW  01
0010A:  MOVWF  14
0010C:  RCALL  0076
....................    spi_writex(0x09, 0x7f); // c = 12.5p
0010E:  MOVLW  09
00110:  MOVWF  13
00112:  MOVLW  7F
00114:  MOVWF  14
00116:  RCALL  0076
....................    spi_writex(0x0a, 0x05);
00118:  MOVLW  0A
0011A:  MOVWF  13
0011C:  MOVLW  05
0011E:  MOVWF  14
00120:  RCALL  0076
....................    spi_writex(0x0b, 0xf4); // gpio0 rx data output
00122:  MOVLW  0B
00124:  MOVWF  13
00126:  MOVLW  F4
00128:  MOVWF  14
0012A:  RCALL  0076
....................    spi_writex(0x0c, 0xfd); // gpio vdd
0012C:  MOVLW  0C
0012E:  MOVWF  13
00130:  MOVLW  FD
00132:  MOVWF  14
00134:  RCALL  0076
....................    spi_writex(0x0d, 0xfd); // gpio vdd
00136:  MOVLW  0D
00138:  MOVWF  13
0013A:  MOVLW  FD
0013C:  MOVWF  14
0013E:  RCALL  0076
....................    spi_writex(0x0e, 0x00); // gpio 0, 1,2 NO OTHER FUNCTION.
00140:  MOVLW  0E
00142:  MOVWF  13
00144:  CLRF   14
00146:  RCALL  0076
....................    spi_writex(0x70, 0x20); // disable manchest
00148:  MOVLW  70
0014A:  MOVWF  13
0014C:  MOVLW  20
0014E:  MOVWF  14
00150:  RCALL  0076
....................    spi_writex(0x1d, 0x00); // enable afc
00152:  MOVLW  1D
00154:  MOVWF  13
00156:  CLRF   14
00158:  RCALL  0076
....................    spi_writex(0x1c, 0x1d); // RATE_24K: // 2.4k
0015A:  MOVLW  1C
0015C:  MOVWF  13
0015E:  MOVLW  1D
00160:  MOVWF  14
00162:  RCALL  0076
....................    spi_writex(0x20,0x41);//0x20 calculate from the datasheet= 500*(1+2*down3_bypass)/(2^ndec*RB*(1+enmanch))
00164:  MOVLW  20
00166:  MOVWF  13
00168:  MOVLW  41
0016A:  MOVWF  14
0016C:  RCALL  0076
....................    spi_writex(0x21, 0x60); // 0x21 , rxosr[10--8] = 0; stalltr = (default), ccoff[19:16] = 0;
0016E:  MOVLW  21
00170:  MOVWF  13
00172:  MOVLW  60
00174:  MOVWF  14
00176:  RCALL  0076
....................    spi_writex(0x22, 0x27); // 0x22 ncoff =5033 = 0x13a9
00178:  MOVLW  22
0017A:  MOVWF  13
0017C:  MOVLW  27
0017E:  MOVWF  14
00180:  RCALL  0076
....................    spi_writex(0x23, 0x52); // 0x23
00182:  MOVLW  23
00184:  MOVWF  13
00186:  MOVLW  52
00188:  MOVWF  14
0018A:  RCALL  0076
....................    spi_writex(0x24, 0x00); // 0x24
0018C:  MOVLW  24
0018E:  MOVWF  13
00190:  CLRF   14
00192:  RCALL  0076
....................    spi_writex(0x25, 0x06); // 0x25
00194:  MOVLW  25
00196:  MOVWF  13
00198:  MOVLW  06
0019A:  MOVWF  14
0019C:  RCALL  0076
....................    spi_writex(0x2a, 0x1e);
0019E:  MOVLW  2A
001A0:  MOVWF  13
001A2:  MOVLW  1E
001A4:  MOVWF  14
001A6:  RCALL  0076
....................    spi_writex(0x30, 0x8c); // enable packet handler, msb first, enable crc,
001A8:  MOVLW  30
001AA:  MOVWF  13
001AC:  MOVLW  8C
001AE:  MOVWF  14
001B0:  RCALL  0076
.................... // 0x31 only readable
....................    spi_writex(0x32, 0xff); // 0x32address enable for headere byte 0, 1,2,3, receive header check for byte 0, 1,2,3
001B2:  MOVLW  32
001B4:  MOVWF  13
001B6:  SETF   14
001B8:  RCALL  0076
....................    spi_writex(0x33, 0x42); // header 3, 2, 1,0 used for head length, fixed packet length,synchronize word length 3, 2,
001BA:  MOVLW  33
001BC:  MOVWF  13
001BE:  MOVLW  42
001C0:  MOVWF  14
001C2:  RCALL  0076
....................    spi_writex(0x34, 64); // 64 nibble = 32byte preamble
001C4:  MOVLW  34
001C6:  MOVWF  13
001C8:  MOVLW  40
001CA:  MOVWF  14
001CC:  RCALL  0076
....................    spi_writex(0x35, 0x20); //0x35 need to detect 20bit preamble
001CE:  MOVLW  35
001D0:  MOVWF  13
001D2:  MOVLW  20
001D4:  MOVWF  14
001D6:  RCALL  0076
....................    spi_writex(0x36, 0x2d); // synchronize word
001D8:  MOVLW  36
001DA:  MOVWF  13
001DC:  MOVLW  2D
001DE:  MOVWF  14
001E0:  RCALL  0076
....................    spi_writex(0x37, 0xd4);
001E2:  MOVLW  37
001E4:  MOVWF  13
001E6:  MOVLW  D4
001E8:  MOVWF  14
001EA:  RCALL  0076
....................    spi_writex(0x38, 0x00);
001EC:  MOVLW  38
001EE:  MOVWF  13
001F0:  CLRF   14
001F2:  RCALL  0076
....................    spi_writex(0x39, 0x00);
001F4:  MOVLW  39
001F6:  MOVWF  13
001F8:  CLRF   14
001FA:  RCALL  0076
....................    spi_writex(0x3f, 's'); // check hearder
001FC:  MOVLW  3F
001FE:  MOVWF  13
00200:  MOVLW  73
00202:  MOVWF  14
00204:  RCALL  0076
....................    spi_writex(0x40, 'o');
00206:  MOVLW  40
00208:  MOVWF  13
0020A:  MOVLW  6F
0020C:  MOVWF  14
0020E:  RCALL  0076
....................    spi_writex(0x41, 'n');
00210:  MOVLW  41
00212:  MOVWF  13
00214:  MOVLW  6E
00216:  MOVWF  14
00218:  RCALL  0076
....................    spi_writex(0x42, 'g');
0021A:  MOVLW  42
0021C:  MOVWF  13
0021E:  MOVLW  67
00220:  MOVWF  14
00222:  RCALL  0076
....................    spi_writex(0x43, 0xff); // all the bit to be checked
00224:  MOVLW  43
00226:  MOVWF  13
00228:  SETF   14
0022A:  RCALL  0076
....................    spi_writex(0x44, 0xff); // all the bit to be checked
0022C:  MOVLW  44
0022E:  MOVWF  13
00230:  SETF   14
00232:  RCALL  0076
....................    spi_writex(0x45, 0xff); // all the bit to be checked
00234:  MOVLW  45
00236:  MOVWF  13
00238:  SETF   14
0023A:  RCALL  0076
....................    spi_writex(0x46, 0xff); // all the bit to be checked
0023C:  MOVLW  46
0023E:  MOVWF  13
00240:  SETF   14
00242:  RCALL  0076
.................... // 0x56 ---------0x6c ??????????????????????????
....................    spi_writex(0x79, 0x0); // no hopping
00244:  MOVLW  79
00246:  MOVWF  13
00248:  CLRF   14
0024A:  RCALL  0076
....................    spi_writex(0x7a, 0x0); // no hopping
0024C:  MOVLW  7A
0024E:  MOVWF  13
00250:  CLRF   14
00252:  RCALL  0076
....................    spi_writex(0x71, 0x22); // Gfsk, fd[8] =0, no invert for Tx/Rx data, fifo mode, txclk -->gpio
00254:  MOVLW  71
00256:  MOVWF  13
00258:  MOVLW  22
0025A:  MOVWF  14
0025C:  RCALL  0076
....................    spi_writex(0x73, 0x0);
0025E:  MOVLW  73
00260:  MOVWF  13
00262:  CLRF   14
00264:  RCALL  0076
....................    spi_writex(0x74, 0x0); // no offset
00266:  MOVLW  74
00268:  MOVWF  13
0026A:  CLRF   14
0026C:  RCALL  0076
.................... //band 434:
....................    spi_writex(0x75, fb); // hbsel = 0, sbsel =1 ???, fb = 19
0026E:  MOVLW  75
00270:  MOVWF  13
00272:  MOVFF  10,14
00276:  RCALL  0076
....................    spi_writex(0x76, fc0); // 25600= 0x6400 for 434Mhz
00278:  MOVLW  76
0027A:  MOVWF  13
0027C:  MOVFF  11,14
00280:  RCALL  0076
....................    spi_writex(0x77, fc1);
00282:  MOVLW  77
00284:  MOVWF  13
00286:  MOVFF  12,14
0028A:  RCALL  0076
0028C:  GOTO   03DE (RETURN)
.................... }
.................... 
.................... void rx_data()
.................... {  
....................    spi_writex(0x07|0x80, SI4432_PWRSTATE_READY); // enter Ready mode
*
002B8:  MOVLW  87
002BA:  MOVWF  13
002BC:  MOVLW  01
002BE:  MOVWF  14
002C0:  RCALL  0076
....................    delay_ms(5); // stablize the OSC; not needed if OSC is on
002C2:  MOVLW  05
002C4:  MOVWF  10
002C6:  RCALL  0290
....................    spi_writex(0x0e|0x80, 0x02);//TX0_RX1 antenna switch = Rx mode
002C8:  MOVLW  8E
002CA:  MOVWF  13
002CC:  MOVLW  02
002CE:  MOVWF  14
002D0:  RCALL  0076
....................    spi_writex(0x08, 0x03); //clear Tx/Rx fifo
002D2:  MOVLW  08
002D4:  MOVWF  13
002D6:  MOVLW  03
002D8:  MOVWF  14
002DA:  RCALL  0076
....................    spi_writex(0x08, 0x00); //clear Tx/Rx fifo  WE MUST SET TO THE DEFAUT VALUES=0
002DC:  MOVLW  08
002DE:  MOVWF  13
002E0:  CLRF   14
002E2:  RCALL  0076
....................    spi_writex(0x07,SI4432_PWRSTATE_RX ); // enter Rx mode //AUTOMATICALLY CLEARED WHEN A VALID PACKET RECýEVED
002E4:  MOVLW  07
002E6:  MOVWF  13
002E8:  MOVLW  05
002EA:  MOVWF  14
002EC:  RCALL  0076
....................    spi_writex(0x05, SI4432_Rx_packet_received_interrupt); // interrupt for packet received
002EE:  MOVLW  05
002F0:  MOVWF  13
002F2:  MOVLW  02
002F4:  MOVWF  14
002F6:  RCALL  0076
....................    //when we write interrupt in 0x05 register we must read status registers(03h,04h) in order to enable nIRQ=0 pin.
....................    //after that we must read status registers for disable the interrupts.
....................    ItStatus1 = spi_readx(0x03); // read status, clear interrupt
002F8:  MOVLW  03
002FA:  MOVWF  13
002FC:  RCALL  0014
002FE:  MOVFF  01,04
....................    ItStatus2 = spi_readx(0x04);
00302:  MOVLW  04
00304:  MOVWF  13
00306:  RCALL  0014
00308:  MOVFF  01,05
0030C:  GOTO   03EE (RETURN)
.................... }
.................... 
.................... unsigned char spi_writex(unsigned char addr , unsigned char data )
.................... {  
....................    unsigned char i;
....................    //make sure to use addr|0x80 in the argument of addr for writing mode
....................    addr|=0x80;
*
00076:  BSF    13.7
....................    output_low(SCLK);
00078:  BCF    F95.2
0007A:  BCF    F8C.2
....................    output_low(nSEL); // must be low during the data read write
0007C:  BCF    F95.1
0007E:  BCF    F8C.1
....................    for(i=0;i<8;i++)
00080:  CLRF   15
00082:  MOVF   15,W
00084:  SUBLW  07
00086:  BNC   00A8
....................    {
....................       if(addr&0x80)
00088:  BTFSS  13.7
0008A:  BRA    0092
....................       output_high(SDO);
0008C:  BCF    F95.3
0008E:  BSF    F8C.3
00090:  BRA    0096
....................       else 
....................       output_low(SDO);
00092:  BCF    F95.3
00094:  BCF    F8C.3
....................       addr<<=1;
00096:  BCF    FD8.0
00098:  RLCF   13,F
....................       output_high(SCLK);
0009A:  BCF    F95.2
0009C:  BSF    F8C.2
....................       delay_cycles(1);
0009E:  NOP   
....................       output_low(SCLK);   
000A0:  BCF    F95.2
000A2:  BCF    F8C.2
000A4:  INCF   15,F
000A6:  BRA    0082
....................    } 
....................    for(i=0;i<8;i++)
000A8:  CLRF   15
000AA:  MOVF   15,W
000AC:  SUBLW  07
000AE:  BNC   00D0
....................    {
....................       if(data&0x80) //if bit of data is 1 
000B0:  BTFSS  14.7
000B2:  BRA    00BA
....................       output_high(SDO);
000B4:  BCF    F95.3
000B6:  BSF    F8C.3
000B8:  BRA    00BE
....................       else //if bit of data is 0
....................       output_low(SDO);
000BA:  BCF    F95.3
000BC:  BCF    F8C.3
....................       data<<=1;   
000BE:  BCF    FD8.0
000C0:  RLCF   14,F
....................       output_high(SCLK); 
000C2:  BCF    F95.2
000C4:  BSF    F8C.2
....................       delay_cycles(1);
000C6:  NOP   
....................       output_low(SCLK);
000C8:  BCF    F95.2
000CA:  BCF    F8C.2
000CC:  INCF   15,F
000CE:  BRA    00AA
....................    }
....................    output_high(nSEL); // must be high after finish Writing addr and data
000D0:  BCF    F95.1
000D2:  BSF    F8C.1
....................    output_high(SCLK);
000D4:  BCF    F95.2
000D6:  BSF    F8C.2
....................    return data;
000D8:  MOVFF  14,01
000DC:  RETURN 0
.................... }
.................... unsigned char spi_readx(unsigned char addr)
.................... {
....................    unsigned char i;
....................    output_low(SCLK);
*
00014:  BCF    F95.2
00016:  BCF    F8C.2
....................    output_low(nSEL); // must be low during the addr write
00018:  BCF    F95.1
0001A:  BCF    F8C.1
....................    for(i=0;i<8;i++)
0001C:  CLRF   14
0001E:  MOVF   14,W
00020:  SUBLW  07
00022:  BNC   0044
....................    {
....................       if(addr&0x80)
00024:  BTFSS  13.7
00026:  BRA    002E
....................       output_high(SDO);
00028:  BCF    F95.3
0002A:  BSF    F8C.3
0002C:  BRA    0032
....................       else 
....................       output_low(SDO);
0002E:  BCF    F95.3
00030:  BCF    F8C.3
....................       addr<<=1;
00032:  BCF    FD8.0
00034:  RLCF   13,F
....................       output_high(SCLK);
00036:  BCF    F95.2
00038:  BSF    F8C.2
....................       delay_cycles(1);
0003A:  NOP   
....................       output_low(SCLK);  
0003C:  BCF    F95.2
0003E:  BCF    F8C.2
00040:  INCF   14,F
00042:  BRA    001E
....................    }
....................       output_low(SDO);
00044:  BCF    F95.3
00046:  BCF    F8C.3
....................       unsigned data;
....................    for(i=0;i<8;i++)
00048:  CLRF   14
0004A:  MOVF   14,W
0004C:  SUBLW  07
0004E:  BNC   0068
....................    {             
.................... //!      if(data&0x80)
.................... //!      output_high(SDO);
.................... //!      else 
.................... //!      output_low(SDO);
....................       data <<= 1;
00050:  BCF    FD8.0
00052:  RLCF   15,F
....................       output_high(SCLK);  
00054:  BCF    F95.2
00056:  BSF    F8C.2
....................       if(input(SDI)) // reading the actual data from rf module
00058:  BSF    F94.4
0005A:  BTFSS  F82.4
0005C:  BRA    0060
....................         { data|=0x01;}
0005E:  BSF    15.0
.................... //!   else
.................... //!     { data&=0xfe;}
....................       //data<<=1; //else kullanmazsak bunu alta da yazabiliriz.
....................       output_low(SCLK);
00060:  BCF    F95.2
00062:  BCF    F8C.2
00064:  INCF   14,F
00066:  BRA    004A
....................    }
....................       output_high(nSEL); 
00068:  BCF    F95.1
0006A:  BSF    F8C.1
....................       output_high(SCLK);
0006C:  BCF    F95.2
0006E:  BSF    F8C.2
....................    return data;
00070:  MOVFF  15,01
00074:  RETURN 0
.................... }
.................... 
.................... unsigned char spi_R(unsigned char data)
.................... {  
....................    unsigned char i;
....................    for(i=0;i<8;i++)
*
00310:  CLRF   13
00312:  MOVF   13,W
00314:  SUBLW  07
00316:  BNC   0342
....................    {
....................   
....................       if(data&0x80) //if bit of data is 1 
00318:  BTFSS  12.7
0031A:  BRA    0322
....................       output_high(SDO);
0031C:  BCF    F95.3
0031E:  BSF    F8C.3
00320:  BRA    0326
....................       else //if bit of data is 0
....................       output_low(SDO);
00322:  BCF    F95.3
00324:  BCF    F8C.3
....................       data<<=1;   
00326:  BCF    FD8.0
00328:  RLCF   12,F
....................       output_high(SCLK); 
0032A:  BCF    F95.2
0032C:  BSF    F8C.2
....................       if(input(SDI))
0032E:  BSF    F94.4
00330:  BTFSS  F82.4
00332:  BRA    0338
....................       data|=0x01;
00334:  BSF    12.0
00336:  BRA    033A
....................       else
....................       data&=0xfe;
00338:  BCF    12.0
....................       output_low(SCLK);
0033A:  BCF    F95.2
0033C:  BCF    F8C.2
0033E:  INCF   13,F
00340:  BRA    0312
....................    }
....................    return data;
00342:  MOVFF  12,01
00346:  RETURN 0
.................... }
.................... 

Configuration Fuses:
   Word  1: F200   HSH PLLEN PRIMARY_ON FCMEN IESO
   Word  2: 1C18   PUT NOBROWNOUT BORV19 NOWDT WDT128
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
